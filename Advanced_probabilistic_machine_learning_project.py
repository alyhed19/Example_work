# -*- coding: utf-8 -*-
"""miniproject_PML.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dmhAikZrKZeFfakU1iqfBi3jSkBmN5zz
"""

import numpy as np 
import matplotlib.pyplot as plt
from scipy.stats import truncnorm, norm
import time
import csv
from operator import itemgetter
import random
import pandas as pd
import seaborn as sns
np.random.seed(42)

"""#Q5"""

def first_gibbs_sampler(K, show_plot):
  s1 = np.zeros(K)
  s2 = np.zeros(K)
  t = np.zeros(K)

  #initialize means and sigmas for s1 and s2 (same hyperparameters(excercise requirement))
  mean1 = 10
  mean2 = 10

  var1 = 2
  var2 = 2
  var3 = 5 # we set this value

  sigma1 = np.sqrt(var1)
  sigma2 = np.sqrt(var2)
  sigma3 = np.sqrt(var3)

  #draw initial values for s1 and s2 from a normal distribution with the predefined parameters
  s1[0] = np.random.normal(mean1, sigma1)
  s2[0] = np.random.normal(mean2, sigma2)

  mean3 = s1[0] - s2[0]

  a, b  = 0, np.inf

  # mu = s1[0] - s2[0]
  a_new, b_new = (a - mean3) / sigma3, (b - mean3) / sigma3
  t[0] = truncnorm.rvs(loc=mean3, scale=sigma3, a=a_new, b=b_new, size=1)

  # s1[0] = 22.234 
  # s2[0] = 12.2342
  # t[0] = 34.324
  cov = np.linalg.inv([[((1/var1)+(1/var3)), (-1/var3)],
                        [(-1/var3), ((1/var2)+(1/var3))]])

  plt.figure(figsize=[18, 6])

  for k in range(K-1):
    m = [(mean1/var1+t[k]/var3),
         (mean2/var2)-(t[k]/var3)]

    mean = np.matmul(cov,m)

    s1[k+1],s2[k+1] = np.random.multivariate_normal(mean, cov, 1).T

    mu = s1[k+1] - s2[k+1]
    a_new, b_new = (a - mu) / sigma3, (b - mu) / sigma3
    t[k+1]  = truncnorm.rvs(a_new, b_new, size=1)

    # a, b = (a - mu) / sigma3, (b - mu) / sigma3
    # # print(a)
    # # print(b)
    # t[k+1]  = truncnorm.rvs(a, b, size=1)
  if show_plot:
    plt.figure(figsize=(20, 8))
    plt.plot(s1, label='s1')
    plt.plot(s2, label='s2')
    plt.plot(t, label='t')
    plt.title('Gibbs sampling')
    plt.xlabel('k')
    plt.ylabel('score')
    plt.legend()
    plt.grid()
    plt.show()

  return s1, s2

s1, s2 = first_gibbs_sampler(40000, True)

"""There is not a clear burn-in area, therefore, we calculate the mean for the posterior distribution from k=0."""

def plot_histograms(s1, s2):
  mu1_post = np.mean(s1) # compute mean from sampling
  mu2_post = np.mean(s2)
  print(f'mu1 posterior: {round(mu1_post, 2)}')
  print(f'mu2 posterior: {round(mu2_post, 2)}')
  sigma1_post = np.std(s1)
  sigma2_post = np.std(s2)
  print(f'sigma1 posterior: {round(sigma1_post, 2)}')
  print(f'sigma2 posterior: {round(sigma2_post, 2)}')

  fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, sharex=True, sharey=True)

  fig.set_size_inches(12, 6)
  fig.suptitle(f'Histograms with {len(s1)} samples', fontsize=16)

  count, bins, ignored = ax1.hist(s1, bins=30, density=True)
  ax1.plot(bins, 1/(sigma1_post*np.sqrt(2*np.pi))*np.exp(-(bins-mu1_post)**2/(2*sigma1_post**2)), linewidth=2, color='r', label='pdf')
  ax1.set_title('Histogram for s1')
  ax1.set_xlabel('s1')
  ax1.set_ylabel('density')
  ax1.legend()

  count, bins, ignored = ax2.hist(s2, bins=30, density=True)
  ax2.plot(bins, 1/(sigma2_post*np.sqrt(2*np.pi))*np.exp(-(bins-mu2_post)**2/(2*sigma2_post**2)), linewidth=2, color='r', label='pdf')
  ax2.set_title('Histogram for s2')
  ax2.set_xlabel('s2')
  ax2.set_ylabel('density')
  ax2.legend()

  plt.show()

t0 = time.perf_counter()
s1, s2 = first_gibbs_sampler(2000, False)
plot_histograms(s1, s2)
print(f'Computing time: {round(time.perf_counter() - t0, 4)}')

t0 = time.perf_counter()
s1, s2 = first_gibbs_sampler(400, False)
plot_histograms(s1, s2)
print(f'Computing time: {round(time.perf_counter() - t0, 4)}')

t0 = time.perf_counter()
s1, s2 = first_gibbs_sampler(10000, False)
plot_histograms(s1, s2)
print(f'Computing time: {round(time.perf_counter() - t0, 4)}')

t0 = time.perf_counter()
s1, s2 = first_gibbs_sampler(20000, False)
plot_histograms(s1, s2)
print(f'Computing time: {round(time.perf_counter() - t0, 4)}')

t0 = time.perf_counter()
s1, s2 = first_gibbs_sampler(40000, False)
plot_histograms(s1, s2)
print(f'Computing time: {round(time.perf_counter() - t0, 4)}')

t0 = time.perf_counter()
s1, s2 = first_gibbs_sampler(800, False)
plot_histograms(s1, s2)
print(f'Computing time: {round(time.perf_counter() - t0, 4)}')

t0 = time.perf_counter()
s1, s2 = first_gibbs_sampler(1200, False)
plot_histograms(s1, s2)
print(f'Computing time: {round(time.perf_counter() - t0, 4)}')

t0 = time.perf_counter()
s1, s2 = first_gibbs_sampler(1600, False)
plot_histograms(s1, s2)
print(f'Computing time: {round(time.perf_counter() - t0, 4)}')

mu1_post = np.mean(s1)
sigma1_post = np.std(s1)
mean1 = 10
var1 = 2
sigma1 = np.sqrt(var1)

mu2_post = np.mean(s2)
sigma2_post = np.std(s2)
mean2 = 10
var2 = 2
sigma2 = np.sqrt(var2)

xv = np.linspace(0,20,100) 
plt.plot(xv,1/(sigma1_post*np.sqrt(2*np.pi))*np.exp(-(xv-mu1_post)**2/(2*sigma1_post**2)), linewidth=2, color='r', label='p(s1|y=1)')
plt.plot(xv,1/(sigma1*np.sqrt(2*np.pi))*np.exp(-(xv-mean1)**2/(2*sigma1**2)), linewidth=2, color='b', label='p(s1)')
plt.legend()
plt.show()

plt.plot(xv,1/(sigma2_post*np.sqrt(2*np.pi))*np.exp(-(xv-mu2_post)**2/(2*sigma2_post**2)), linewidth=2, color='r', label='p(s2|y=1)')
plt.plot(xv,1/(sigma2*np.sqrt(2*np.pi))*np.exp(-(xv-mean2)**2/(2*sigma2**2)), linewidth=2, color='b', label='p(s2)')
plt.legend()
plt.show()

"""#Q6"""

# import numpy as np 
# import matplotlib.pyplot as plt 
# from scipy.stats import truncnorm
# from numpy import genfromtxt

# #read data from csv file
# data = genfromtxt('/content/SerieA.csv', delimiter=',', names=True, dtype=None, encoding=None)

# team1 = data['team1']
# team2 = data['team2']
# score1 = data['score1']
# score2 = data['score2']

# #create a list of teams names
# teams = set(team1)
# number_of_teams = len(teams)

# #initial parameters (user choice)
# mean = 30
# sigma = 3
# #create a list with initial teams skills by drawing from a normal distribution 
# skills = np.random.normal(mean,sigma,size=number_of_teams)

# #create a dictionary for the teams and their skills values
# dic = dict(zip(teams,skills))
# #print(dic)
#print(dic["Roma"])

# #traverse the match list
# for i in range(len(data)):
#   if data[i]['score1'] > data[i]['score2']:
#     pass
#   else:
#     pass

def gibbs_sampler(mean1,mean2,var1,var2,var3,y):
 
  K = 400

  s1 = np.zeros(K)
  s2 = np.zeros(K)
  t = np.zeros(K)

  #initialize means and sigmas for s1 and s2 (same hyperparameters(excercise requirement))

  sigma1 = np.sqrt(var1)
  sigma2 = np.sqrt(var2)
  sigma3 = np.sqrt(var3)

  #draw initial values for s1 and s2 from a normal distribution with the predefined parameters
  s1[0] = np.random.normal(mean1, sigma1)
  s2[0] = np.random.normal(mean2, sigma2)

  mean3 = s1[0] - s2[0]

  if y == 1:
    a, b  = 0, np.inf
  elif y == -1:
    a, b = np.NINF, 0

  mu = s1[0] - s2[0]
  a_new, b_new = (a - mu) / sigma3, (b - mu) / sigma3
  t[0] = truncnorm.rvs(loc=mean3, scale=sigma3, a=a_new, b=b_new, size=1)

  cov = np.linalg.inv([[((1/var1)+(1/var3)), (- 1/var3)],
                        [(-1/var3), ((1/var2)+(1/var3))]])

  # plt.figure(figsize=[20, 6])

  for k in range(K-1):
    m = [(mean1/var1+t[k]/var3),
        (mean2/var2)-(t[k]/var3)]

    mean = np.matmul(cov,m)

    s1[k+1],s2[k+1] = np.random.multivariate_normal(mean, cov, 1).T

    mu = s1[k+1] - s2[k+1]
    a_new, b_new = (a - mu) / sigma3, (b - mu) / sigma3
    t[k+1]  = truncnorm.rvs(a_new, b_new, size=1)


  mu1_post = np.mean(s1[10:]) # compute mean from sampling from k= 10
  mu2_post = np.mean(s2[10:])

  var1_post = np.var(s1[10:])
  var2_post = np.var(s2[10:])
  # sigma3_post = np.std(t)
  # var3_post = sigma3_post**2

  return mu1_post,mu2_post,var1_post,var2_post#,var3_post

def ranking(matches):
  for row in matchlist:
      if int(row['score1']) > int(row['score2']):
          row['y'] = 1
      elif int(row['score1']) < int(row['score2']): 
          row['y'] = -1
      elif int(row['score1']) == int(row['score2']):
          row['y'] = 0

  #initialize means and sigmas for s1 and s2 (same hyperparameters(excercise requirement))
  mean1 = 2
  mean2 = 2

  var1 = 1
  var2 = 1
  var3 = 2 # we set this value

  # y = 1

  team_names = set()
  for row in matchlist:
      team_names.add(row['team1'])
      team_names.add(row['team2'])

  team_skills = []
  for team in team_names:
      team_skills.append({'name':team,'mean':mean1, 'var': var1})

  # print(team_skills)

  for row in matchlist:
      if row['y'] != 0: 
          for team in team_skills:
              if row['team1'] == team['name']:
                  mean1 = team['mean']
                  var1 = team['var']

              if row['team2'] == team['name']:
                  mean2 = team['mean']
                  var2 = team['var']
          
          mu1_post,mu2_post,var1_post,var2_post = gibbs_sampler(mean1,mean2,var1,var2,var3,row['y'])   
          
          for team in team_skills:
              if row['team1'] == team['name']:
                  team['mean'] = round(mu1_post,3)
                  team['var'] = round(var1_post,3)

              if row['team2'] == team['name']:
                  team['mean'] = round(mu2_post,3)
                  team['var'] = round(var2_post,3)

  top_teams = sorted(team_skills, key=itemgetter('mean'))

  #print(top_teams)
              
  team_names = []
  team_mean_scores = []
  team_score_var = []
  for teams in top_teams:
      team_names.append(teams['name'])
      team_mean_scores.append(teams['mean'])
      team_score_var.append(teams['var'])

  return team_names, team_mean_scores, team_score_var

with open('./SerieA.csv') as file:
    reader = csv.DictReader(file)
    matchlist = list(reader)

matchlist2 = matchlist.copy()
#Q6b. to randomize the matches
random.shuffle(matchlist2)

team_names, team_mean_scores, team_score_var = ranking(matchlist)
team_names2, team_mean_scores2, team_score_var2 = ranking(matchlist2)

fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, sharex=True)

fig.set_size_inches(20, 5)
fig.suptitle('Team ranking', fontsize=16)

ax1.barh(team_names, team_mean_scores, xerr = team_score_var)
ax2.barh(team_names2, team_mean_scores2, xerr = team_score_var2)

ax1.set_title('Original matches')
ax1.set_xlabel('mean score')
ax1.set_ylabel('Team')

ax2.set_title('Shuffled matches')
ax2.set_xlabel('mean score')
ax2.set_ylabel('Team')

plt.show()

"""#Q7"""

with open('./SerieA.csv') as file:
    reader = csv.DictReader(file)
    matchlist = list(reader)


for row in matchlist:
    if int(row['score1']) > int(row['score2']):
        row['y_actual'] = 1
    elif int(row['score1']) < int(row['score2']): 
        row['y_actual'] = -1
    elif int(row['score1']) == int(row['score2']):
        row['y_actual'] = 0
    row['y_pred'] = None 

#initialize means and sigmas for s1 and s2 (same hyperparameters(excercise requirement))
mean1 = 5
mean2 = 5
var1 = 2
var2 = 2
var3 = 4 # we set this value

team_names = set()
for row in matchlist:
    team_names.add(row['team1'])
    team_names.add(row['team2'])


team_skills = []
for team in team_names:
    team_skills.append({'name':team,'mean':mean1, 'var': var1})

def prediction_func(mean1,mean2):
    
    if mean1 > mean2:
            return 1 # pred is team1 wins
    elif mean1 < mean2:
        return -1 # pred is team2 wins
    elif mean1 == mean2:
        return 0 # pred is draw

for row in matchlist:
    if row['y_actual'] != 0: #neglecting draws
        for team in team_skills:
            if row['team1'] == team['name']:
                mean1 = team['mean']
                var1 = team['var']

            if row['team2'] == team['name']:
                mean2 = team['mean']
                var2 = team['var']
        
        # predict the match output
        row['y_pred'] = prediction_func(mean1,mean2)

        # use the actual match output to update model
        mu1_post,mu2_post,var1_post,var2_post = gibbs_sampler(mean1,mean2,var1,var2,var3,row['y_actual'])   
        
        for team in team_skills:
            if row['team1'] == team['name']:
                team['mean'] = round(mu1_post,3)
                team['var'] = round(var1_post,3)

            if row['team2'] == team['name']:
                team['mean'] = round(mu2_post,3)
                team['var'] = round(var2_post,3)

correct_guesses = 0
total_guesses = 0
for row in matchlist:
    if row['y_actual']!=0:
        total_guesses +=1
        if row['y_pred'] == row ['y_actual']:
            correct_guesses +=1

print(f'prediction rate = {round(correct_guesses/total_guesses,4)*100}%')

"""#Q9"""

def mutiplyGauss(m1, s1, m2, s2):
# computes the Gaussian distribution N(m,s) being propotional to N(m1,s1)*N(m2,s2)
#
# Input:
# m1, s1: mean and variance of first Gaussian
# m2, s2: mean and variance of second Gaussian
#
# Output:
# m, s: mean and variance of the product Gaussian
    # s = 1/(1/s1+1/s2)
    # m = (m1/s1+m2/s2)*s
    #trying the formula from the lecture
    s = (s1*s2)/(s1+s2)
    m = (m1*s2+m2*s1)/(s1+s2)
    return m, s

def divideGauss(m1, s1, m2, s2):
# computes the Gaussian distribution N(m,s) being propotional to N(m1,s1)/N(m2,s2)
#
# Input:
# m1, s1: mean and variance of the numerator Gaussian
# m2, s2: mean and variance of the denominator Gaussian
#
# Output:
# m, s: mean and variance of the quotient Gaussian
    # m, s = mutiplyGauss(m1, s1, m2, -s2)
    #trying the formula from the lecture
    m = (m1*s2-m2*s1)/(s2-s1)
    s = (s1*s2)/(s2-s1)
    return m, s

def truncGaussMM(a, b, m0, s0):
# computes the mean and variance of a truncated Gaussian distribution
#
# Input:
# a, b: The interval [a, b] on which the Gaussian is being truncated
# m0,s0: mean and variance of the Gaussian which is to be truncated
 # Output:
# m, s: mean and variance of the truncated Gaussian
# scale interval with mean and variance
    a_scaled , b_scaled = (a - m0) / np.sqrt(s0), (b - m0) / np.sqrt(s0)
    m = truncnorm.mean(a_scaled, b_scaled, loc=m0, scale=np.sqrt(s0))
    s = truncnorm.var(a_scaled, b_scaled, loc=m0, scale=np.sqrt(s0))
    return m, s

def message_passing(mean1,mean2,var1,var2,var3,y,date_diff_1 = 0.0,date_diff_2 = 0.0):

    var_t1 = round(0.0001 * date_diff_1, 5)
    var_t2 = round(0.0001 * date_diff_2, 5)

    # Message mu1 from prior to node s1
    mu1_m = mean1 # mean of message
    mu1_s = var1 + var_t1 # variance of message

    # Message mu2 from prior to node s2
    mu2_m = mean2 # mean of message
    mu2_s = var2 + var_t2 # variance of message

    # Message mu3 from node s1 to factor f_s1s2t
    mu3_m = mu1_m # mean of message
    mu3_s = mu1_s # variance of message

    # Message mu4 from node s2 to factor f_s1s2t
    mu4_m = mu2_m # mean of message
    mu4_s = mu2_s # variance of message

    # Message mu5 from factor f_s1s2t to node t
    mu5_m = mu3_m - mu4_m 
    mu5_s = mu3_s + mu4_s + var3

    # Do moment matching of the marginal of t
    if y == 1:
        a, b = 0, np.Inf
    else:
        a, b = np.NINF, 0

    pt_m, pt_s = truncGaussMM(a, b, mu5_m, mu5_s)

    # Compute the message from t to f_s1s2t
    mu8_m, mu8_s = divideGauss(pt_m, pt_s, mu5_m, mu5_s)

    # Compute the message from f_s1s2t to s1
    mu9_m = mu8_m + mu2_m
    mu9_s = mu2_s + mu8_s + var3
    # Compute the marginal of s1
    ps1_m, ps1_s = mutiplyGauss(mu1_m, mu1_s, mu9_m, mu9_s)


    # Compute the message from f_s1s2t to s2
    mu10_m = mu1_m - mu8_m 
    mu10_s = mu1_s + mu8_s + var3
    # Compute the marginal of x
    ps2_m, ps2_s = mutiplyGauss(mu2_m, mu2_s, mu10_m, mu10_s)

    return ps1_m,ps2_m,ps1_s,ps2_s

mean1 = 25 # The mean of the prior p(s1)
mean2 = 35 # The mean of the prior p(s2)
var1 = 5 # The variance of the prior p(s1)
var2 = 3 # The variance of the prior p(s2)
var3 = 2 # The variance of p(t|s1,s2)
y = 1 # The measurement

ps1_m,ps2_m,ps1_s,ps2_s = message_passing(mean1,mean2,var1,var2,var3,y)   

mu1_post,mu2_post,var1_post,var2_post = gibbs_sampler(mean1,mean2,var1,var2,var3,y)   

n_samples = 1000
s1_posterior_pdf = np.random.normal(mu1_post, np.sqrt(var1_post), n_samples)
s2_posterior_pdf = np.random.normal(mu2_post, np.sqrt(var2_post), n_samples)

fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, sharex=True, sharey=True)
xv = np.linspace(ps1_m - 3*ps1_s, ps1_m + 3*ps1_s, 100)
# plt.hist(s2g,density=True,bins=np.linspace(0,10,50))
ax1.hist(s1_posterior_pdf, bins=30, density=True)
ax1.plot(xv,norm.pdf(xv,ps1_m, np.sqrt(ps1_s)), linewidth=2, color='r', label='p(s1|y=1)')
ax1.legend()

xv = np.linspace(ps2_m - 3*ps2_s, ps2_m + 3*ps2_s, 100)
# plt.hist(s2g,density=True,bins=np.linspace(0,10,50))
ax2.hist(s2_posterior_pdf, bins=30, density=True)
ax2.plot(xv,norm.pdf(xv,ps2_m, np.sqrt(ps2_s)), linewidth=2, color='r', label='p(s2|y=1)')
ax2.legend()
plt.show()

"""#Q10"""

DATA_PATH = '/content/own data - Ice hockey - KHL  2018-2019.csv'
df = pd.read_csv(DATA_PATH)
df.head()

df = df[['Home Team ', 'Away Team', 'Winner']]

y_actual = []
for i, row in df.iterrows():
  if row['Winner'] == row['Home Team ']:
    y_actual.append(1)
  elif row['Winner'] == row['Away Team']:
    y_actual.append(-1)
  else:
    print('eiii')
    y_actual.append(None)

df['y_actual'] = y_actual

unique_teams_home = df['Home Team '].unique()
unique_teams_away = df['Away Team'].unique()
unique_teams_home.sort() == unique_teams_away.sort() # check that we have all teams in both columns

unique_teams = unique_teams_home

#initialize means and sigmas for s1 and s2 (same hyperparameters(excercise requirement))
mean1 = 5
mean2 = 5
var1 = 2
var2 = 2
var3 = 4 # we set this value

team_skills = []
for team in unique_teams:
  team_skills.append({'name': team, 'mean': mean1, 'var': var1})

# Calculate predictions
y_preds = []
for i, row in df.iterrows():
  for team in team_skills:
    if row['Home Team '] == team['name']:
      mean1 = team['mean']
      var1 = team['var']

    elif row['Away Team'] == team['name']:
      mean2 = team['mean']
      var2 = team['var']
        
  # predict the match output
  y_preds.append(prediction_func(mean1, mean2))

  # use the actual match output to update model
  mu1_post, mu2_post, var1_post, var2_post = gibbs_sampler(mean1, mean2, var1, var2, var3, row['y_actual'])   
        
  for team in team_skills:
    if row['Home Team '] == team['name']:
      team['mean'] = mu1_post
      team['var'] = var1_post

    elif row['Away Team'] == team['name']:
      team['mean'] = mu2_post
      team['var'] = var2_post

df['y_pred'] = y_preds

# Calculate accuracy
correct_guesses = 0
total_guesses = 0
for i, row in df.iterrows():
    if row['y_pred'] == row['y_actual']:
      correct_guesses += 1
    total_guesses += 1

print(f'prediction rate = {round(100*correct_guesses/total_guesses, 4)}%')

"""#Q11"""

def prediction_func(mean1,mean2):
    
    if mean1 > mean2:
            return 1 # pred is team1 wins
    elif mean1 < mean2:
        return -1 # pred is team2 wins
    elif mean1 == mean2:
        return 0 # pred is draw

def mutiplyGauss(m1, s1, m2, s2):
# computes the Gaussian distribution N(m,s) being propotional to N(m1,s1)*N(m2,s2)
#
# Input:
# m1, s1: mean and variance of first Gaussian
# m2, s2: mean and variance of second Gaussian
#
# Output:
# m, s: mean and variance of the product Gaussian
    s = 1/(1/s1+1/s2)
    m = (m1/s1+m2/s2)*s
    return m, s

def divideGauss(m1, s1, m2, s2):
# computes the Gaussian distribution N(m,s) being propotional to N(m1,s1)/N(m2,s2)
#
# Input:
# m1, s1: mean and variance of the numerator Gaussian
# m2, s2: mean and variance of the denominator Gaussian
#
# Output:
# m, s: mean and variance of the quotient Gaussian
    m, s = mutiplyGauss(m1, s1, m2, -s2)
    return m, s

def truncGaussMM(a, b, m0, s0):
# computes the mean and variance of a truncated Gaussian distribution
#
# Input:
# a, b: The interval [a, b] on which the Gaussian is being truncated
# m0,s0: mean and variance of the Gaussian which is to be truncated
 # Output:
# m, s: mean and variance of the truncated Gaussian
# scale interval with mean and variance
    a_scaled , b_scaled = (a - m0) / np.sqrt(s0), (b - m0) / np.sqrt(s0)
    m = truncnorm.mean(a_scaled, b_scaled, loc=m0, scale=np.sqrt(s0))
    s = truncnorm.var(a_scaled, b_scaled, loc=m0, scale=np.sqrt(s0))
    return m, s

def message_passing(mean1,mean2,var1,var2,var3,y,date_diff_1 = 0.0,date_diff_2 = 0.0):

    var_t1 = round(0.0001 * date_diff_1, 5)
    var_t2 = round(0.0001 * date_diff_2, 5)

    # Message mu1 from prior to node s1
    mu1_m = mean1 # mean of message
    mu1_s = var1 + var_t1 # variance of message

    # Message mu2 from prior to node s2
    mu2_m = mean2 # mean of message
    mu2_s = var2 + var_t2 # variance of message

    # Message mu3 from node s1 to factor f_s1s2t
    mu3_m = mu1_m # mean of message
    mu3_s = mu1_s # variance of message

    # Message mu4 from node s2 to factor f_s1s2t
    mu4_m = mu2_m # mean of message
    mu4_s = mu2_s # variance of message

    # Message mu5 from factor f_s1s2t to node t
    mu5_m = mu3_m - mu4_m 
    mu5_s = mu3_s + mu4_s + var3

    # Do moment matching of the marginal of t
    if y == 1:
        a, b = 0, np.Inf
    else:
        a, b = np.NINF, 0

    pt_m, pt_s = truncGaussMM(a, b, mu5_m, mu5_s)

    # Compute the message from t to f_s1s2t
    mu8_m, mu8_s = divideGauss(pt_m, pt_s, mu5_m, mu5_s)

    # Compute the message from f_s1s2t to s1
    mu9_m = mu8_m + mu2_m
    mu9_s = mu2_s + mu8_s + var3
    # Compute the marginal of s1
    ps1_m, ps1_s = mutiplyGauss(mu1_m, mu1_s, mu9_m, mu9_s)


    # Compute the message from f_s1s2t to s2
    mu10_m = mu1_m - mu8_m 
    mu10_s = mu1_s + mu8_s + var3
    # Compute the marginal of x
    ps2_m, ps2_s = mutiplyGauss(mu2_m, mu2_s, mu10_m, mu10_s)

    return ps1_m,ps2_m,ps1_s,ps2_s

with open('./SerieA.csv') as file:
    reader = csv.DictReader(file)
    matchlist = list(reader)

for row in matchlist:
    if int(row['score1']) > int(row['score2']):
        row['y_actual'] = 1
    elif int(row['score1']) < int(row['score2']): 
        row['y_actual'] = -1
    elif int(row['score1']) == int(row['score2']):
        row['y_actual'] = 0
    row['y_pred'] = None 

mean1 = 2 # The mean of the prior p(s1)
mean2 = 2 # The mean of the prior p(s2)
var1 = 1 # The variance of the prior p(s1)
var2 = 1 # The variance of the prior p(s2)
var3 = 2 # The variance of p(t|s1,s2)

team_names = set()
for row in matchlist:
    team_names.add(row['team1'])
    team_names.add(row['team2'])


team_skills = []
for team in team_names:
    team_skills.append({'name':team, 'last_played': np.datetime64('nat') ,'mean':mean1, 'var': var1})


# Assumption: the matches are already sorted by timestamps.
# finding first match dates for each team
for team in team_skills:
    for row in matchlist:
        if team['name'] == row['team1'] or team['name'] == row['team2']:
            team['last_played'] =  np.datetime64(row['yyyy-mm-dd'])
            break

for row in matchlist:
    if row['y_actual'] != 0: 
        for team in team_skills:
            if row['team1'] == team['name']:
                mean1 = team['mean']
                var1 = team['var']
                date_diff_1 = (np.datetime64(row['yyyy-mm-dd']) - team['last_played'])/np.timedelta64(1, 'D')

            if row['team2'] == team['name']:
                mean2 = team['mean']
                var2 = team['var']
                date_diff_2 = (np.datetime64(row['yyyy-mm-dd']) - team['last_played'])/np.timedelta64(1, 'D')

        # predict the match output
        row['y_pred'] = prediction_func(mean1,mean2)
        
        mu1_post,mu2_post,var1_post,var2_post = message_passing(mean1,mean2,var1,var2,var3,row['y_actual'],date_diff_1,date_diff_2)   
        # mu1_post,mu2_post,var1_post,var2_post = gibbs_sampler(mean1,mean2,var1,var2,var3,row['y_actual'])   
        
        for team in team_skills:
            if row['team1'] == team['name']:
                team['last_played'] = np.datetime64(row['yyyy-mm-dd'])
                team['mean'] = round(mu1_post,5)
                team['var'] = round(var1_post,5)

            if row['team2'] == team['name']:
                team['last_played'] = np.datetime64(row['yyyy-mm-dd'])
                team['mean'] = round(mu2_post,5)
                team['var'] = round(var2_post,5)

top_teams = sorted(team_skills, key=itemgetter('mean'))

print(top_teams)
            
team_names = []
team_mean_scores = []
team_score_var = []
for teams in top_teams:
    team_names.append(teams['name'])
    team_mean_scores.append(teams['mean'])
    team_score_var.append(teams['var'])
  
fig = plt.figure(figsize = (10, 5))
 
# creating the bar plot
plt.barh(team_names, team_mean_scores, xerr = team_score_var)
 
plt.ylabel("Team names")
plt.xlabel("Team mean score")
plt.title("Team ranking")
plt.show()

correct_guesses = 0
total_guesses = 0
for row in matchlist:
    if row['y_actual']!=0:
        total_guesses +=1
        if row['y_pred'] == row ['y_actual']:
            correct_guesses +=1

print(f'prediction rate = {round(correct_guesses/total_guesses,4)*100}%')